@startuml CDMF_Security_Architecture

title CDMF Security Architecture - Multi-Layer Defense

@startuml Security_Layers
title Security Defense-in-Depth - Five Layers

package "Layer 5: Audit & Monitoring" #Pink {
    [Security Event Logger]
    [Audit Trail]
    [Intrusion Detection]
    [Metrics Collector]

    note right of [Security Event Logger]
      **Events Logged:**
      - Module loading
      - Permission checks
      - Security violations
      - Signature verification
      - IPC connections
    end note
}

package "Layer 4: Runtime Protection" #LightCoral {
    [Sandbox Manager]
    [Resource Limiter]
    [Process Isolation]

    [Sandbox Manager] : seccomp-BPF filter
    [Sandbox Manager] : AppArmor profile
    [Sandbox Manager] : Syscall filtering
    [Resource Limiter] : cgroups (CPU, memory)
    [Resource Limiter] : ulimit (files, processes)
    [Process Isolation] : Separate address spaces

    note right of [Sandbox Manager]
      **Sandboxing:**
      - syscall whitelist
      - Filesystem restrictions
      - Network restrictions
      - Capability restrictions
    end note
}

package "Layer 3: Access Control" #LightYellow {
    [Permission Manager]
    [Service Access Control]
    [File Access Control]
    [Network Access Control]

    [Permission Manager] : Permission types
    [Permission Manager] : Grant/revoke
    [Permission Manager] : Check enforcement
    [Service Access Control] : Interface-level
    [File Access Control] : Path-based
    [Network Access Control] : Host/port-based

    note right of [Permission Manager]
      **Permission Types:**
      - SERVICE_ACCESS
      - FILE_READ / FILE_WRITE
      - NETWORK_CONNECT
      - NETWORK_LISTEN
      - EXECUTE
      - LOAD_MODULE
    end note
}

package "Layer 2: Communication Security" #LightGreen {
    [IPC Authentication]
    [Message Integrity]
    [Channel Encryption]

    [IPC Authentication] : Peer credentials
    [IPC Authentication] : UID/GID verification
    [Message Integrity] : HMAC-SHA256
    [Channel Encryption] : TLS 1.3 (gRPC)

    note right of [IPC Authentication]
      **Unix Socket Security:**
      - SO_PEERCRED
      - File permissions (0600)
      - Owner verification

      **gRPC Security:**
      - mTLS authentication
      - Certificate-based
    end note
}

package "Layer 1: Code Integrity" #LightBlue {
    [Code Verifier]
    [Signature Verification]
    [Certificate Validation]
    [Trust Store]

    [Code Verifier] : SHA-256 hashing
    [Signature Verification] : RSA-4096
    [Certificate Validation] : X.509 chain
    [Trust Store] : Root CA certificates

    note right of [Code Verifier]
      **Verification Process:**
      1. Compute file hash (SHA-256)
      2. Verify RSA signature
      3. Validate certificate chain
      4. Check expiration
      5. Verify trust store
    end note
}

[Security Event Logger] --> [Sandbox Manager]
[Security Event Logger] --> [Permission Manager]
[Security Event Logger] --> [IPC Authentication]
[Security Event Logger] --> [Code Verifier]

[Sandbox Manager] --> [Process Isolation]
[Sandbox Manager] --> [Resource Limiter]

[Permission Manager] --> [Service Access Control]
[Permission Manager] --> [File Access Control]
[Permission Manager] --> [Network Access Control]

[IPC Authentication] --> [Message Integrity]
[IPC Authentication] --> [Channel Encryption]

[Code Verifier] --> [Signature Verification]
[Signature Verification] --> [Certificate Validation]
[Certificate Validation] --> [Trust Store]

@enduml

@startuml Code_Signing_Detailed
title Code Signing and Verification - Detailed Process

participant "Module Developer" as DEV
participant "Code Signer" as SIGNER
participant "Module Binary" as BIN
participant "Framework" as FW
participant "Code Verifier" as VER
participant "Trust Store" as TRUST

== Signing Process (Development Time) ==

DEV -> SIGNER: signModule("module.so", "private.key")
activate SIGNER

SIGNER -> BIN: readFile("module.so")
activate BIN
BIN --> SIGNER: binaryContent
deactivate BIN

SIGNER -> SIGNER: hash = SHA256(binaryContent)
note right: SHA-256 digest:\n32 bytes

SIGNER -> SIGNER: loadPrivateKey("private.key")
SIGNER -> SIGNER: signature = RSA_sign(hash, privateKey)
note right: RSA-4096 signature:\n512 bytes

SIGNER -> SIGNER: createSignatureFile()
SIGNER -> BIN: writeFile("module.so.sig", signature)

SIGNER -> SIGNER: createMetadata()
note right
  ```json
  {
    "algorithm": "RSA-SHA256",
    "key_size": 4096,
    "timestamp": 1696204800,
    "cert_fingerprint": "sha256:abc123..."
  }
  ```
end note

SIGNER -> BIN: writeFile("module.so.sig.json", metadata)

SIGNER --> DEV: module signed
deactivate SIGNER

== Verification Process (Load Time) ==

FW -> VER: verifyModule("/path/to/module.so")
activate VER

VER -> BIN: readFile("module.so")
activate BIN
BIN --> VER: binaryContent
deactivate BIN

VER -> BIN: readFile("module.so.sig")
activate BIN
BIN --> VER: signatureData
deactivate BIN

VER -> VER: hash = SHA256(binaryContent)

VER -> VER: extractCertificate(signatureData)
VER -> VER: cert = parseCertificate()

VER -> TRUST: verifyCertificateChain(cert)
activate TRUST

TRUST -> TRUST: loadRootCAs()
loop Build certificate chain
    TRUST -> TRUST: currentCert = cert
    loop while !currentCert.isSelfSigned()
        TRUST -> TRUST: issuer = findIssuer(currentCert)
        alt Issuer not found
            TRUST --> VER: false (broken chain)
            VER --> FW: throw SecurityException("Broken cert chain")
        end
        TRUST -> TRUST: chain.append(issuer)
        TRUST -> TRUST: currentCert = issuer
    end
end

TRUST -> TRUST: rootCert = chain.last()
TRUST -> TRUST: isTrusted = rootCerts.contains(rootCert)
alt Not trusted
    TRUST --> VER: false
    VER --> FW: throw SecurityException("Untrusted certificate")
end

TRUST --> VER: certificate valid
deactivate TRUST

VER -> VER: publicKey = cert.getPublicKey()
VER -> VER: verified = RSA_verify(hash, signatureData, publicKey)

alt Verification failed
    VER --> FW: false
    FW -> FW: throw SecurityException("Signature verification failed")
end

VER -> VER: checkExpiration(cert)
alt Certificate expired
    VER --> FW: false
    FW -> FW: throw SecurityException("Certificate expired")
end

VER --> FW: true (verified)
deactivate VER

FW -> FW: proceedWithModuleLoad()

note over DEV, TRUST
  **Security Properties:**
  - Integrity: Hash ensures no tampering
  - Authenticity: Signature proves origin
  - Trust: Certificate chain to trusted CA
  - Non-repudiation: Private key holder only
end note

@enduml

@startuml Sandboxing_Detailed
title Sandboxing - seccomp-BPF and AppArmor

participant "Framework" as FW
participant "Sandbox Manager" as SAND
participant "seccomp Filter" as SECCOMP
participant "AppArmor" as AA
participant "Resource Limiter" as RLIM
participant "Module Process" as PROC

FW -> SAND: applySandbox(module, policy)
activate SAND

== seccomp-BPF Filter ==

SAND -> SECCOMP: loadProfile("sandbox.json")
activate SECCOMP

note right of SECCOMP
  ```json
  {
    "allowed_syscalls": [
      "read", "write", "open", "close",
      "stat", "fstat", "poll", "lseek",
      "mmap", "munmap", "brk",
      "rt_sigaction", "rt_sigprocmask",
      "ioctl", "getpid"
    ],
    "blocked_syscalls": [
      "ptrace", "fork", "vfork", "clone",
      "execve", "socket", "connect"
    ]
  }
  ```
end note

SECCOMP -> SECCOMP: buildBPFProgram()
loop For each allowed syscall
    SECCOMP -> SECCOMP: filter.add(BPF_ALLOW(syscall))
end
SECCOMP -> SECCOMP: filter.add(BPF_DENY_ALL)

SECCOMP -> SECCOMP: prog = compileBPF(filter)
SECCOMP --> SAND: bpfProgram
deactivate SECCOMP

== AppArmor Profile ==

SAND -> AA: loadProfile("module_profile")
activate AA

note right of AA
  Profile: /etc/apparmor.d/cdmf.module
  ```
  #include <tunables/global>

  /opt/cdmf/modules/untrusted/* {
    #include <abstractions/base>

    # Read module files
    /opt/cdmf/modules/untrusted/** r,

    # Write to temp
    /tmp/cdmf-@{pid}/** rw,

    # IPC socket
    /tmp/cdmf-ipc-@{pid}.sock rw,

    # Deny network
    deny network,

    # Deny sensitive files
    deny /etc/** r,
    deny /home/** r,

    # Deny capabilities
    deny capability,
  }
  ```
end note

AA -> AA: parseProfile()
AA -> AA: compileProfile()
AA --> SAND: profileLoaded
deactivate AA

== Resource Limits ==

SAND -> RLIM: applyLimits(pid, limits)
activate RLIM

note right of RLIM
  ```json
  {
    "max_memory_mb": 256,
    "max_cpu_percent": 25,
    "max_open_files": 100,
    "max_processes": 1
  }
  ```
end note

RLIM -> RLIM: createCgroup("/sys/fs/cgroup/cdmf/module_" + pid)

RLIM -> RLIM: setCPULimit()
note right: cpu.max = "25000 100000" (25%)

RLIM -> RLIM: setMemoryLimit()
note right: memory.max = 268435456 (256MB)

RLIM -> RLIM: addProcessToCgroup(pid)
RLIM --> SAND: limits applied
deactivate RLIM

== Process Fork & Apply ==

SAND -> PROC: fork()
activate PROC

PROC -> PROC: prctl(PR_SET_NO_NEW_PRIVS, 1)
note right: Prevents privilege escalation

PROC -> PROC: prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, prog)
note right: Apply seccomp filter

PROC -> PROC: aa_change_profile("cdmf.module")
note right: Apply AppArmor profile

PROC -> PROC: loadModule("module.so")

alt Violation Attempt
    PROC -> PROC: syscall(fork)
    SECCOMP -> PROC: SIGSYS (signal)
    PROC -> PROC: terminate
    note right: Violation logged and process killed
end

PROC --> SAND: module running in sandbox
deactivate PROC

SAND --> FW: sandbox applied
deactivate SAND

note over FW, PROC
  **Sandbox Enforcement:**
  - seccomp: Syscall-level filtering
  - AppArmor: Filesystem access control
  - cgroups: Resource limits
  - Violations: Immediate termination

  **Attack Surface Reduced:**
  - Network access: Denied
  - File access: Restricted to /tmp
  - Process creation: Blocked
  - Privilege escalation: Impossible
end note

@enduml

@startuml Permission_Model
title Permission Model - Access Control

class Permission {
    - type_: PermissionType
    - resource_: string
    - action_: string
    __
    + Permission(type, resource, action)
    + implies(other: Permission) : bool
    - matchesWildcard(pattern, value) : bool
}

enum PermissionType {
    SERVICE_ACCESS
    FILE_READ
    FILE_WRITE
    NETWORK_CONNECT
    NETWORK_LISTEN
    EXECUTE
    LOAD_MODULE
}

class SecurityManager {
    - modulePermissions_: map<Module*, vector<Permission>>
    - mutex_: shared_mutex
    __
    + checkPermission(module, permission)
    + grantPermission(module, permission)
    + revokePermission(module, permission)
    + getPermissions(module) : vector<Permission>
}

class SecureServiceRegistry {
    - securityManager_: SecurityManager*
    - baseRegistry_: ServiceRegistry*
    __
    + getService(requester, serviceRef) : void*
    + registerService(...) : ServiceRegistration
    - checkServicePermission(module, interfaceName)
}

Permission *-- PermissionType
SecurityManager o-- Permission
SecureServiceRegistry --> SecurityManager

note top of Permission
  **Permission Examples:**

  **Service Access:**
  Permission(SERVICE_ACCESS, "com.example.ILogger", "*")
  → Can access ILogger service

  **File Read:**
  Permission(FILE_READ, "/data/**", "*")
  → Can read any file under /data/

  **File Write:**
  Permission(FILE_WRITE, "/tmp/module/**", "*")
  → Can write to /tmp/module/ only

  **Network Connect:**
  Permission(NETWORK_CONNECT, "api.example.com:443", "*")
  → Can connect to api.example.com on port 443

  **Wildcard Matching:**
  "/data/**" matches "/data/foo.txt", "/data/sub/bar.txt"
  "com.example.*" matches "com.example.ILogger", "com.example.IDatabase"
end note

@startuml Permission_Check_Sequence

participant "Client Module" as CLIENT
participant "SecureServiceRegistry" as SREG
participant "SecurityManager" as SEC
participant "Service Implementation" as IMPL

CLIENT -> SREG: getService(serviceRef)
activate SREG

SREG -> SEC: checkPermission(client, Permission(SERVICE_ACCESS, interfaceName, "*"))
activate SEC

SEC -> SEC: permissions = modulePermissions_[client]
loop For each granted permission
    SEC -> SEC: if permission.implies(requested)
    alt Permission Found
        SEC --> SREG: allowed
        note right: Permission granted
    end
end

alt No Permission Found
    SEC --> SREG: throw SecurityException
    SREG --> CLIENT: SecurityException("Permission denied")
end

deactivate SEC

SREG -> SREG: service = baseRegistry_.getService(serviceRef)
SREG --> CLIENT: service
deactivate SREG

CLIENT -> IMPL: method(args)
activate IMPL
IMPL --> CLIENT: result
deactivate IMPL

note over CLIENT, IMPL
  **Permission Enforcement:**
  - Every service access checked
  - Fine-grained control per module
  - Wildcard support for flexibility
  - Failures throw SecurityException
end note

@enduml

@startuml Threat_Model
title Threat Model and Mitigations

agent "Attacker" as ATK
cloud "Attack Surface" as SURF

rectangle "CDMF Framework" {
    component [Module Loading] as ML
    component [Service Calls] as SC
    component [IPC Channels] as IPC
    component [Configuration] as CFG
    component [Logs] as LOG
}

ATK --> SURF
SURF --> ML : Malicious module
SURF --> SC : Unauthorized access
SURF --> IPC : IPC tampering
SURF --> CFG : Config manipulation
SURF --> LOG : Log tampering

note right of ML
  **Threat:** Malicious module loading
  **Impact:** Code execution
  **Mitigation:**
  - Code signing (RSA-4096)
  - Certificate validation
  - Trust store
  **Risk:** LOW
end note

note right of SC
  **Threat:** Unauthorized service access
  **Impact:** Privilege escalation
  **Mitigation:**
  - Permission model
  - Access control checks
  - Sandboxing
  **Risk:** LOW
end note

note right of IPC
  **Threat:** IPC message tampering
  **Impact:** Data corruption
  **Mitigation:**
  - HMAC-SHA256
  - Unix socket permissions
  - gRPC TLS
  **Risk:** MEDIUM
end note

note right of CFG
  **Threat:** Configuration tampering
  **Impact:** Framework compromise
  **Mitigation:**
  - File permissions (0600)
  - Integrity checks
  - Root-only write
  **Risk:** MEDIUM
end note

note right of LOG
  **Threat:** Log tampering
  **Impact:** Hide attacks
  **Mitigation:**
  - Append-only logs
  - Remote logging
  - File permissions
  **Risk:** LOW
end note

@enduml

@enduml
