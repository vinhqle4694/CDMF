/**
 * @file protobuf_serializer.cpp
 * @brief Protocol Buffers serializer implementation
 *
 * NOTE: This implementation assumes the protobuf message definitions have been
 * compiled from message.proto using protoc. In a real build, you would:
 * 1. Run: protoc --cpp_out=. message.proto
 * 2. Include the generated message.pb.h and message.pb.cc files
 * 3. Link against libprotobuf
 *
 * For this demonstration, we provide a complete implementation pattern.
 *
 * @version 1.0.0
 * @date 2025-10-03
 * @author Serialization Agent
 */

#include "ipc/protobuf_serializer.h"
#include "utils/log.h"
#include <cstring>
#include <algorithm>

// NOTE: In a real implementation, you would include the generated protobuf header:
// #include "message.pb.h"

// For demonstration, we'll define a minimal protobuf-like interface
// In production, this would be auto-generated by protoc
namespace cdmf {
namespace ipc {
namespace proto {

// These would normally be auto-generated by protoc
// We provide simplified versions for demonstration

struct ProtoBufMessage {
    std::vector<uint8_t> serialized_data;

    bool SerializeToArray(void* data, int size) const {
        if (size < static_cast<int>(serialized_data.size())) {
            return false;
        }
        std::memcpy(data, serialized_data.data(), serialized_data.size());
        return true;
    }

    bool SerializeToString(std::string* output) const {
        output->assign(reinterpret_cast<const char*>(serialized_data.data()),
                      serialized_data.size());
        return true;
    }

    bool ParseFromArray(const void* data, int size) {
        if (size < 0) return false;
        serialized_data.assign(static_cast<const uint8_t*>(data),
                              static_cast<const uint8_t*>(data) + size);
        return true;
    }

    size_t ByteSize() const {
        return serialized_data.size();
    }

    void Clear() {
        serialized_data.clear();
    }
};

} // namespace proto
} // namespace ipc
} // namespace cdmf

namespace cdmf {
namespace ipc {

// Helper functions for protobuf serialization

namespace {

/**
 * @brief Writes varint-encoded value (protobuf wire format)
 */
void writeVarint(std::vector<uint8_t>& buffer, uint64_t value) {
    while (value >= 0x80) {
        buffer.push_back(static_cast<uint8_t>((value & 0x7F) | 0x80));
        value >>= 7;
    }
    buffer.push_back(static_cast<uint8_t>(value & 0x7F));
}

/**
 * @brief Reads varint-encoded value
 */
bool readVarint(const uint8_t*& data, const uint8_t* end, uint64_t& value) {
    value = 0;
    int shift = 0;

    while (data < end) {
        uint8_t byte = *data++;
        value |= static_cast<uint64_t>(byte & 0x7F) << shift;

        if ((byte & 0x80) == 0) {
            return true;
        }

        shift += 7;
        if (shift >= 64) {
            return false;  // Overflow
        }
    }

    return false;  // Incomplete varint
}

/**
 * @brief Writes length-delimited field (tag + length + data)
 */
void writeLengthDelimited(std::vector<uint8_t>& buffer, uint32_t field_number,
                          const std::vector<uint8_t>& data) {
    // Field tag (field_number << 3 | wire_type)
    // Wire type 2 = length-delimited
    writeVarint(buffer, (static_cast<uint64_t>(field_number) << 3) | 2);
    writeVarint(buffer, data.size());
    buffer.insert(buffer.end(), data.begin(), data.end());
}

/**
 * @brief Writes bytes field
 */
void writeBytes(std::vector<uint8_t>& buffer, uint32_t field_number,
                const uint8_t* data, size_t size) {
    writeVarint(buffer, (static_cast<uint64_t>(field_number) << 3) | 2);
    writeVarint(buffer, size);
    buffer.insert(buffer.end(), data, data + size);
}

/**
 * @brief Writes string field
 */
void writeString(std::vector<uint8_t>& buffer, uint32_t field_number,
                 const std::string& str) {
    writeVarint(buffer, (static_cast<uint64_t>(field_number) << 3) | 2);
    writeVarint(buffer, str.size());
    buffer.insert(buffer.end(), str.begin(), str.end());
}

/**
 * @brief Writes uint32 field
 */
void writeUInt32(std::vector<uint8_t>& buffer, uint32_t field_number, uint32_t value) {
    // Wire type 0 = varint
    writeVarint(buffer, (static_cast<uint64_t>(field_number) << 3) | 0);
    writeVarint(buffer, value);
}

/**
 * @brief Writes uint64 field
 */
void writeUInt64(std::vector<uint8_t>& buffer, uint32_t field_number, uint64_t value) {
    writeVarint(buffer, (static_cast<uint64_t>(field_number) << 3) | 0);
    writeVarint(buffer, value);
}

/**
 * @brief Writes enum field (same as uint32)
 */
void writeEnum(std::vector<uint8_t>& buffer, uint32_t field_number, uint32_t value) {
    writeUInt32(buffer, field_number, value);
}

/**
 * @brief Serializes message header to protobuf format
 */
std::vector<uint8_t> serializeHeader(const MessageHeader& header) {
    std::vector<uint8_t> data;

    // Field 1: message_id (bytes)
    writeBytes(data, 1, header.message_id, 16);

    // Field 2: correlation_id (bytes)
    writeBytes(data, 2, header.correlation_id, 16);

    // Field 3: timestamp (uint64)
    writeUInt64(data, 3, header.timestamp);

    // Field 4: type (enum)
    writeEnum(data, 4, static_cast<uint32_t>(header.type));

    // Field 5: priority (enum)
    writeEnum(data, 5, static_cast<uint32_t>(header.priority));

    // Field 6: format (enum)
    writeEnum(data, 6, static_cast<uint32_t>(header.format));

    // Field 7: version (uint32)
    writeUInt32(data, 7, header.version);

    // Field 8: flags (uint32)
    writeUInt32(data, 8, header.flags);

    // Field 9: payload_size (uint32)
    writeUInt32(data, 9, header.payload_size);

    // Field 10: checksum (uint32)
    writeUInt32(data, 10, header.checksum);

    return data;
}

/**
 * @brief Serializes metadata to protobuf format
 */
std::vector<uint8_t> serializeMetadata(const MessageMetadata& metadata) {
    std::vector<uint8_t> data;

    // Field 1: source_endpoint (string)
    if (!metadata.source_endpoint.empty()) {
        writeString(data, 1, metadata.source_endpoint);
    }

    // Field 2: destination_endpoint (string)
    if (!metadata.destination_endpoint.empty()) {
        writeString(data, 2, metadata.destination_endpoint);
    }

    // Field 3: subject (string)
    if (!metadata.subject.empty()) {
        writeString(data, 3, metadata.subject);
    }

    // Field 4: content_type (string)
    if (!metadata.content_type.empty()) {
        writeString(data, 4, metadata.content_type);
    }

    // Field 5: expiration (uint64)
    auto expiration_time = metadata.expiration.time_since_epoch();
    auto micros = std::chrono::duration_cast<std::chrono::microseconds>(expiration_time);
    writeUInt64(data, 5, static_cast<uint64_t>(micros.count()));

    // Field 6: retry_count (uint32)
    writeUInt32(data, 6, metadata.retry_count);

    // Field 7: max_retries (uint32)
    writeUInt32(data, 7, metadata.max_retries);

    return data;
}

/**
 * @brief Serializes error info to protobuf format
 */
std::vector<uint8_t> serializeErrorInfo(const ErrorInfo& error) {
    std::vector<uint8_t> data;

    // Field 1: error_code (uint32)
    writeUInt32(data, 1, error.error_code);

    // Field 2: error_message (string)
    if (!error.error_message.empty()) {
        writeString(data, 2, error.error_message);
    }

    // Field 3: error_category (string)
    if (!error.error_category.empty()) {
        writeString(data, 3, error.error_category);
    }

    // Field 4: error_context (string)
    if (!error.error_context.empty()) {
        writeString(data, 4, error.error_context);
    }

    return data;
}

/**
 * @brief Deserializes header from protobuf format
 */
bool deserializeHeader(const uint8_t* data, size_t size, MessageHeader& header) {
    const uint8_t* ptr = data;
    const uint8_t* end = data + size;

    while (ptr < end) {
        uint64_t tag;
        if (!readVarint(ptr, end, tag)) return false;

        uint32_t field_number = static_cast<uint32_t>(tag >> 3);
        uint32_t wire_type = static_cast<uint32_t>(tag & 0x7);

        switch (field_number) {
            case 1: { // message_id
                uint64_t length;
                if (!readVarint(ptr, end, length) || length != 16) return false;
                if (ptr + length > end) return false;
                std::memcpy(header.message_id, ptr, 16);
                ptr += length;
                break;
            }
            case 2: { // correlation_id
                uint64_t length;
                if (!readVarint(ptr, end, length) || length != 16) return false;
                if (ptr + length > end) return false;
                std::memcpy(header.correlation_id, ptr, 16);
                ptr += length;
                break;
            }
            case 3: { // timestamp
                uint64_t value;
                if (!readVarint(ptr, end, value)) return false;
                header.timestamp = value;
                break;
            }
            case 4: { // type
                uint64_t value;
                if (!readVarint(ptr, end, value)) return false;
                header.type = static_cast<MessageType>(value);
                break;
            }
            case 5: { // priority
                uint64_t value;
                if (!readVarint(ptr, end, value)) return false;
                header.priority = static_cast<MessagePriority>(value);
                break;
            }
            case 6: { // format
                uint64_t value;
                if (!readVarint(ptr, end, value)) return false;
                header.format = static_cast<SerializationFormat>(value);
                break;
            }
            case 7: { // version
                uint64_t value;
                if (!readVarint(ptr, end, value)) return false;
                header.version = static_cast<uint8_t>(value);
                break;
            }
            case 8: { // flags
                uint64_t value;
                if (!readVarint(ptr, end, value)) return false;
                header.flags = static_cast<uint32_t>(value);
                break;
            }
            case 9: { // payload_size
                uint64_t value;
                if (!readVarint(ptr, end, value)) return false;
                header.payload_size = static_cast<uint32_t>(value);
                break;
            }
            case 10: { // checksum
                uint64_t value;
                if (!readVarint(ptr, end, value)) return false;
                header.checksum = static_cast<uint32_t>(value);
                break;
            }
            default: {
                // Unknown field - skip it (forward compatibility)
                if (wire_type == 0) { // Varint
                    uint64_t value;
                    if (!readVarint(ptr, end, value)) return false;
                } else if (wire_type == 2) { // Length-delimited
                    uint64_t length;
                    if (!readVarint(ptr, end, length)) return false;
                    if (ptr + length > end) return false;
                    ptr += length;
                } else {
                    return false;  // Unsupported wire type
                }
                break;
            }
        }
    }

    return true;
}

/**
 * @brief Deserializes metadata from protobuf format
 */
bool deserializeMetadata(const uint8_t* data, size_t size, MessageMetadata& metadata) {
    const uint8_t* ptr = data;
    const uint8_t* end = data + size;

    while (ptr < end) {
        uint64_t tag;
        if (!readVarint(ptr, end, tag)) return false;

        uint32_t field_number = static_cast<uint32_t>(tag >> 3);
        uint32_t wire_type = static_cast<uint32_t>(tag & 0x7);

        switch (field_number) {
            case 1: { // source_endpoint
                uint64_t length;
                if (!readVarint(ptr, end, length)) return false;
                if (ptr + length > end) return false;
                metadata.source_endpoint.assign(reinterpret_cast<const char*>(ptr), length);
                ptr += length;
                break;
            }
            case 2: { // destination_endpoint
                uint64_t length;
                if (!readVarint(ptr, end, length)) return false;
                if (ptr + length > end) return false;
                metadata.destination_endpoint.assign(reinterpret_cast<const char*>(ptr), length);
                ptr += length;
                break;
            }
            case 3: { // subject
                uint64_t length;
                if (!readVarint(ptr, end, length)) return false;
                if (ptr + length > end) return false;
                metadata.subject.assign(reinterpret_cast<const char*>(ptr), length);
                ptr += length;
                break;
            }
            case 4: { // content_type
                uint64_t length;
                if (!readVarint(ptr, end, length)) return false;
                if (ptr + length > end) return false;
                metadata.content_type.assign(reinterpret_cast<const char*>(ptr), length);
                ptr += length;
                break;
            }
            case 5: { // expiration
                uint64_t value;
                if (!readVarint(ptr, end, value)) return false;
                auto duration = std::chrono::microseconds(value);
                metadata.expiration = std::chrono::system_clock::time_point(duration);
                break;
            }
            case 6: { // retry_count
                uint64_t value;
                if (!readVarint(ptr, end, value)) return false;
                metadata.retry_count = static_cast<uint32_t>(value);
                break;
            }
            case 7: { // max_retries
                uint64_t value;
                if (!readVarint(ptr, end, value)) return false;
                metadata.max_retries = static_cast<uint32_t>(value);
                break;
            }
            default: {
                // Unknown field - skip it
                if (wire_type == 0) {
                    uint64_t value;
                    if (!readVarint(ptr, end, value)) return false;
                } else if (wire_type == 2) {
                    uint64_t length;
                    if (!readVarint(ptr, end, length)) return false;
                    if (ptr + length > end) return false;
                    ptr += length;
                } else {
                    return false;
                }
                break;
            }
        }
    }

    return true;
}

/**
 * @brief Deserializes error info from protobuf format
 */
bool deserializeErrorInfo(const uint8_t* data, size_t size, ErrorInfo& error) {
    const uint8_t* ptr = data;
    const uint8_t* end = data + size;

    while (ptr < end) {
        uint64_t tag;
        if (!readVarint(ptr, end, tag)) return false;

        uint32_t field_number = static_cast<uint32_t>(tag >> 3);
        uint32_t wire_type = static_cast<uint32_t>(tag & 0x7);

        switch (field_number) {
            case 1: { // error_code
                uint64_t value;
                if (!readVarint(ptr, end, value)) return false;
                error.error_code = static_cast<uint32_t>(value);
                break;
            }
            case 2: { // error_message
                uint64_t length;
                if (!readVarint(ptr, end, length)) return false;
                if (ptr + length > end) return false;
                error.error_message.assign(reinterpret_cast<const char*>(ptr), length);
                ptr += length;
                break;
            }
            case 3: { // error_category
                uint64_t length;
                if (!readVarint(ptr, end, length)) return false;
                if (ptr + length > end) return false;
                error.error_category.assign(reinterpret_cast<const char*>(ptr), length);
                ptr += length;
                break;
            }
            case 4: { // error_context
                uint64_t length;
                if (!readVarint(ptr, end, length)) return false;
                if (ptr + length > end) return false;
                error.error_context.assign(reinterpret_cast<const char*>(ptr), length);
                ptr += length;
                break;
            }
            default: {
                // Unknown field - skip it
                if (wire_type == 0) {
                    uint64_t value;
                    if (!readVarint(ptr, end, value)) return false;
                } else if (wire_type == 2) {
                    uint64_t length;
                    if (!readVarint(ptr, end, length)) return false;
                    if (ptr + length > end) return false;
                    ptr += length;
                } else {
                    return false;
                }
                break;
            }
        }
    }

    return true;
}

} // anonymous namespace

// ProtoBufSerializer implementation

ProtoBufSerializer::ProtoBufSerializer() {
    LOGD_FMT("ProtoBufSerializer - constructor");
    // Initialize protobuf library (if needed)
    // In real implementation: GOOGLE_PROTOBUF_VERIFY_VERSION;
}

ProtoBufSerializer::~ProtoBufSerializer() {
    LOGD_FMT("ProtoBufSerializer - destructor");
    // Cleanup protobuf library (if needed)
    // In real implementation: google::protobuf::ShutdownProtobufLibrary();
}

SerializationResult ProtoBufSerializer::serialize(const Message& message) {
    std::lock_guard<std::mutex> lock(mutex_);

    LOGD_FMT("ProtoBufSerializer::serialize - type: " << static_cast<int>(message.getType())
             << ", payload_size: " << message.getPayloadSize());

    try {
        std::vector<uint8_t> data;

        // Estimate size and reserve
        uint32_t estimated_size = estimateSerializedSize(message);
        data.reserve(estimated_size);
        LOGD_FMT("ProtoBufSerializer::serialize - estimated_size: " << estimated_size);

        // Field 1: header (embedded message)
        std::vector<uint8_t> header_data = serializeHeader(message.getHeader());
        writeLengthDelimited(data, 1, header_data);

        // Field 2: metadata (embedded message)
        std::vector<uint8_t> metadata_data = serializeMetadata(message.getMetadata());
        writeLengthDelimited(data, 2, metadata_data);

        // Field 3: payload (bytes)
        uint32_t payload_size = message.getPayloadSize();
        if (payload_size > 0) {
            writeBytes(data, 3, message.getPayload(), payload_size);
        }

        // Field 4: error_info (embedded message, only for ERROR messages)
        if (message.isError()) {
            std::vector<uint8_t> error_data = serializeErrorInfo(message.getErrorInfo());
            writeLengthDelimited(data, 4, error_data);
        }

        LOGD_FMT("ProtoBufSerializer::serialize - success, size: " << data.size());
        return SerializationResult(std::move(data));

    } catch (const std::exception& e) {
        LOGE_FMT("ProtoBufSerializer::serialize - exception: " << e.what());
        return SerializationResult(error_codes::SERIALIZATION_ERROR,
                                   std::string("ProtoBuf serialization failed: ") + e.what());
    } catch (...) {
        LOGE_FMT("ProtoBufSerializer::serialize - unknown exception");
        return SerializationResult(error_codes::UNKNOWN_ERROR,
                                   "Unknown ProtoBuf serialization error");
    }
}

DeserializationResult ProtoBufSerializer::deserialize(const void* data, uint32_t size) {
    std::lock_guard<std::mutex> lock(mutex_);

    LOGD_FMT("ProtoBufSerializer::deserialize - size: " << size);

    try {
        const uint8_t* ptr = static_cast<const uint8_t*>(data);
        const uint8_t* end = ptr + size;

        auto message = std::make_shared<Message>();

        MessageHeader header;
        MessageMetadata metadata;
        std::vector<uint8_t> payload;
        ErrorInfo error_info;
        bool has_header = false;
        bool has_error_info = false;

        // Parse protobuf message
        while (ptr < end) {
            uint64_t tag;
            if (!readVarint(ptr, end, tag)) {
                return DeserializationResult(error_codes::DESERIALIZATION_ERROR,
                                             "Failed to read field tag");
            }

            uint32_t field_number = static_cast<uint32_t>(tag >> 3);
            uint32_t wire_type = static_cast<uint32_t>(tag & 0x7);

            if (wire_type != 2) {  // All our fields are length-delimited
                return DeserializationResult(error_codes::INVALID_FORMAT,
                                             "Invalid wire type in ProtoBuf message");
            }

            uint64_t length;
            if (!readVarint(ptr, end, length)) {
                return DeserializationResult(error_codes::DESERIALIZATION_ERROR,
                                             "Failed to read field length");
            }

            if (ptr + length > end) {
                return DeserializationResult(error_codes::INSUFFICIENT_DATA,
                                             "Insufficient data for field");
            }

            switch (field_number) {
                case 1: { // header
                    if (!deserializeHeader(ptr, length, header)) {
                        return DeserializationResult(error_codes::DESERIALIZATION_ERROR,
                                                     "Failed to deserialize header");
                    }
                    has_header = true;
                    break;
                }
                case 2: { // metadata
                    if (!deserializeMetadata(ptr, length, metadata)) {
                        return DeserializationResult(error_codes::DESERIALIZATION_ERROR,
                                                     "Failed to deserialize metadata");
                    }
                    break;
                }
                case 3: { // payload
                    payload.assign(ptr, ptr + length);
                    break;
                }
                case 4: { // error_info
                    if (!deserializeErrorInfo(ptr, length, error_info)) {
                        return DeserializationResult(error_codes::DESERIALIZATION_ERROR,
                                                     "Failed to deserialize error info");
                    }
                    has_error_info = true;
                    break;
                }
                default: {
                    // Unknown field - skip it (forward compatibility)
                    break;
                }
            }

            ptr += length;
        }

        if (!has_header) {
            return DeserializationResult(error_codes::INVALID_FORMAT,
                                         "Missing required header field");
        }

        // Populate message
        message->getHeader() = header;
        message->getMetadata() = metadata;

        if (!payload.empty()) {
            if (!message->setPayload(payload.data(), static_cast<uint32_t>(payload.size()))) {
                return DeserializationResult(error_codes::SIZE_EXCEEDED,
                                             "Payload size exceeds maximum");
            }
        }

        if (has_error_info) {
            message->getErrorInfo() = error_info;
        }

        // Verify checksum
        if (!message->verifyChecksum()) {
            LOGE_FMT("ProtoBufSerializer::deserialize - checksum mismatch");
            return DeserializationResult(error_codes::CHECKSUM_MISMATCH,
                                         "Message checksum verification failed");
        }

        LOGD_FMT("ProtoBufSerializer::deserialize - success");
        return DeserializationResult(message);

    } catch (const std::exception& e) {
        LOGE_FMT("ProtoBufSerializer::deserialize - exception: " << e.what());
        return DeserializationResult(error_codes::DESERIALIZATION_ERROR,
                                     std::string("ProtoBuf deserialization failed: ") + e.what());
    } catch (...) {
        LOGE_FMT("ProtoBufSerializer::deserialize - unknown exception");
        return DeserializationResult(error_codes::UNKNOWN_ERROR,
                                     "Unknown ProtoBuf deserialization error");
    }
}

bool ProtoBufSerializer::validate(const void* data, uint32_t size) const {
    std::lock_guard<std::mutex> lock(mutex_);

    LOGD_FMT("ProtoBufSerializer::validate - size: " << size);

    if (size < 2) {  // Minimum protobuf message size
        LOGW_FMT("ProtoBufSerializer::validate - size too small");
        return false;
    }

    const uint8_t* ptr = static_cast<const uint8_t*>(data);
    const uint8_t* end = ptr + size;

    // Quick validation - just check if we can parse the tags
    while (ptr < end) {
        uint64_t tag;
        if (!readVarint(ptr, end, tag)) {
            return false;
        }

        uint32_t wire_type = static_cast<uint32_t>(tag & 0x7);

        if (wire_type == 0) {  // Varint
            uint64_t value;
            if (!readVarint(ptr, end, value)) {
                return false;
            }
        } else if (wire_type == 2) {  // Length-delimited
            uint64_t length;
            if (!readVarint(ptr, end, length)) {
                return false;
            }
            if (ptr + length > end) {
                return false;
            }
            ptr += length;
        } else {
            LOGW_FMT("ProtoBufSerializer::validate - unsupported wire type");
            return false;  // Unsupported wire type
        }
    }

    bool valid = (ptr == end);
    LOGD_FMT("ProtoBufSerializer::validate - result: " << (valid ? "valid" : "invalid"));
    return valid;  // Should consume exactly all data
}

uint32_t ProtoBufSerializer::estimateSerializedSize(const Message& message) const {
    // Estimate protobuf size (with varint overhead)
    uint32_t size = 0;

    // Header field (field tag + length + header data)
    size += 2;  // Field tag (varint)
    size += 2;  // Length (varint)
    size += 60; // Approximate header size with varint encoding

    // Metadata field
    size += 2;  // Field tag
    size += 2;  // Length
    const MessageMetadata& metadata = message.getMetadata();
    size += 4 + static_cast<uint32_t>(metadata.source_endpoint.size());
    size += 4 + static_cast<uint32_t>(metadata.destination_endpoint.size());
    size += 4 + static_cast<uint32_t>(metadata.subject.size());
    size += 4 + static_cast<uint32_t>(metadata.content_type.size());
    size += 12; // Timestamps and counters

    // Payload field
    if (message.getPayloadSize() > 0) {
        size += 2;  // Field tag
        size += 4;  // Length (varint, assume up to 4 bytes)
        size += message.getPayloadSize();
    }

    // Error info field (if applicable)
    if (message.isError()) {
        size += 2;  // Field tag
        size += 2;  // Length
        const ErrorInfo& error = message.getErrorInfo();
        size += 4;  // error_code
        size += 4 + static_cast<uint32_t>(error.error_message.size());
        size += 4 + static_cast<uint32_t>(error.error_category.size());
        size += 4 + static_cast<uint32_t>(error.error_context.size());
    }

    return size;
}

// Enum conversion helpers

int ProtoBufSerializer::convertMessageType(MessageType type) {
    return static_cast<int>(type);
}

MessageType ProtoBufSerializer::convertFromProtoMessageType(int proto_type) {
    return static_cast<MessageType>(proto_type);
}

int ProtoBufSerializer::convertMessagePriority(MessagePriority priority) {
    return static_cast<int>(priority);
}

MessagePriority ProtoBufSerializer::convertFromProtoPriority(int proto_priority) {
    return static_cast<MessagePriority>(proto_priority);
}

int ProtoBufSerializer::convertSerializationFormat(SerializationFormat format) {
    return static_cast<int>(format);
}

SerializationFormat ProtoBufSerializer::convertFromProtoFormat(int proto_format) {
    return static_cast<SerializationFormat>(proto_format);
}

} // namespace ipc
} // namespace cdmf
